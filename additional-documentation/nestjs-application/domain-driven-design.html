<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>schulcloud-server documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../../images/favicon.ico">
	   <link rel="stylesheet" href="../../styles/style.css">
        <link rel="stylesheet" href="../../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../../" class="navbar-brand">schulcloud-server documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content additional-page">
                   <div class="content-data">




















<h1 id="domain-driven-design">Domain driven design</h1>
<p>While <a href="https://khalilstemmler.com/articles/domain-driven-design-intro/">DDD</a> is not enforced, we still try to follow its goals:</p>
<ul>
<li>Discover the domain model by interacting with domain experts and agreeing upon a common set of terms to refer to processes, actors and any other phenomenon that occurs in the domain.</li>
<li>Take those newly discovered terms and embed them in the code, creating a rich domain model that reflects the actual living, breathing business and it&#39;s rules.</li>
<li>Protect that domain model from all the other technical intricacies involved in creating a web application.</li>
</ul>
<h2 id="clean-architecture">Clean Architecture</h2>
<p><img src="https://khalilstemmler.com/img/blog/ddd-intro/clean.jpg" alt="" class="img-responsive"> &quot;The Clean Architecture from the golden Uncle Bob archives&quot;</p>
<p>For the 3-layer architecture this means we have to protect the business layer and domain models from the outside world and infrastructure to keep it clean, fast, testable, ready for changes.</p>
<h2 id="concepts">Concepts</h2>
<h3 id="entities">Entities</h3>
<p>NestJS does not cover how to persist entities, the heart of our application. We need a solution that not only transfers data like mongoose, instead we want to define business rules on objects with strong typing added.</p>
<p>Instead of Interface, Model and Schema which describe the view on data, now we define Entities, that get a DRY possibility to be created, loaded, and persisted using en entity manager. The definition of how an entity relates with others or how it is persisted can be added using decorators.</p>
<p>See <a href="https://github.com/mikro-orm/mikro-orm#-core-features">https://github.com/mikro-orm/mikro-orm#-core-features</a> for further details.</p>
<h3 id="domain-services">Domain Services</h3>
<p>Domain Services are most often executed by application layer Application Services / Use Cases. Because Domain Services are a part of the Domain Layer and adhere to the dependency rule, Domain Services aren&#39;t allowed to depend on infrastructure layer concerns like Repositories to get access to the domain entities that they interact with. Application Services fetch the necessary entities, then pass them to domain services to run allow them to interact.</p>
<p>Sample: Within of a use case we not depend on a user context from outside while for logging, error handling or in a repository it might be used. Like we see in the clean architecture schema.</p>
<h4 id="use-cases">Use Cases</h4>
<p>Beside Concepts NestJS introduces, own services like <a href="https://khalilstemmler.com/articles/domain-driven-design-intro/#Repository">repositories</a> or use-cases might be created.</p>
<p>Use cases either return entities (data) to the user through a query (CRUD) or apply a command (do ... ok/err).
Further reading: <a href="https://khalilstemmler.com/articles/oop-design-principles/command-query-separation/">https://khalilstemmler.com/articles/oop-design-principles/command-query-separation/</a></p>
<p>They focus on providing business use cases and should only contain higher logical function calls, that are well-tested and hide their implementation inside of a use-case.</p>
<div><pre class="line-numbers"><code class="language-TypeScript">    /**
     * Let an existing user create a new user (on same school).
     * &#64;throws: USER_ALREADY_EXISTS, API_VALIDATION_ERROR
     * &#64;throws: FORBIDDEN, BAD_REQUEST, INTERNAL_SERVER_ERROR, ...
     */
    async registerNewUser(creatorId: EntityId, schoolId: EntityId, props: INewUserProps): Promise&lt;User&gt; {
        this.logger.log(`create new user called by ${creatorId}`);

        // check creator has permission in school to create user
        await this.authorizationService.checkEntityPermissions(creatorId, School, schoolId, [&#39;USER_CREATE&#39;]);

        // check user not exists
        await this.userService.checkUserNotExistByEmail(props.email)

        const user = new User(props);
        await this.userRepo.save(user);

        if(enableUserActivation){
            // call other service which creates pin and sends email
        }

        if(sendWelcomeEmailToUser){
            await this.userEmailService.sendWelcomeMessage(user);
        }

        this.logger.log(`user ${user.id} created by user ${creatorId}`);

        return user;
    }


    // ... userService

    checkUserNotExistByEmail(email: string){
        // todo email is not empty
        const existingUser = await this.userRepo.findByEmail(props.email);
        if(existingUser.length &gt; 0) {
            throw new UserAlreadyExistError();
        }
    }</code></pre></div><p>How to structure a use case? When creating a use case, care of</p>
<ul>
<li>the general business goal</li>
<li>preconditions</li>
<li>actors, in-put &amp; out-put data</li>
<li>post conditions to be well-known</li>
<li>the normal case (step by step)</li>
<li>all (handled) exception-cases (to be handled in a client application)</li>
</ul>
<h5 id="clean-code-principles">Clean Code principles</h5>
<p>A use case should consist only of business-rules and decisions (functional requirements), while the final implementation is part of functions that are called from the use case. There, we no more see any details about the functional requirements.</p>
<h3 id="domain-events">Domain events</h3>
<p>Events have to be handled very carefully or in best case not to be used. Like hooks around services might lead into separating the business logic into independend untestable workflows, the events task and data must be defined clearly and should only be used for independent tasks.</p>

                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 2;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'additional-page';
            var COMPODOC_CURRENT_PAGE_URL = 'domain-driven-design.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../../js/libs/custom-elements.min.js"></script>
       <script src="../../js/libs/lit-html.js"></script>

       <script src="../../js/menu-wc.js" defer></script>
       <script nomodule src="../../js/menu-wc_es5.js" defer></script>

       <script src="../../js/libs/bootstrap-native.js"></script>

       <script src="../../js/libs/es6-shim.min.js"></script>
       <script src="../../js/libs/EventDispatcher.js"></script>
       <script src="../../js/libs/promise.min.js"></script>
       <script src="../../js/libs/zepto.min.js"></script>

       <script src="../../js/compodoc.js"></script>

       <script src="../../js/tabs.js"></script>
       <script src="../../js/menu.js"></script>
       <script src="../../js/libs/clipboard.min.js"></script>
       <script src="../../js/libs/prism.js"></script>
       <script src="../../js/sourceCode.js"></script>
          <script src="../../js/search/search.js"></script>
          <script src="../../js/search/lunr.min.js"></script>
          <script src="../../js/search/search-lunr.js"></script>
          <script src="../../js/search/search_index.js"></script>
       <script src="../../js/lazy-load-graphs.js"></script>


    </body>
</html>
